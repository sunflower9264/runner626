<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Runner626 - åœ°å›¾ç¼–è¾‘å™¨</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c3e50;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        .sidebar {
            width: 300px;
            background: #34495e;
            color: white;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }
        
        .sidebar h2 {
            margin-bottom: 15px;
            color: #3498db;
            font-size: 1.3em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .toolbar {
            background: #34495e;
            padding: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .toolbar button, .toolbar select {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .toolbar button {
            background: #3498db;
            color: white;
            font-weight: bold;
        }
        
        .toolbar button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }
        
        .toolbar button.danger {
            background: #e74c3c;
        }
        
        .toolbar button.danger:hover {
            background: #c0392b;
        }
        
        .toolbar button.active {
            background: #27ae60;
        }
        
        .toolbar select {
            background: white;
            border: 2px solid #3498db;
        }
        
        #game-container {
            flex: 1;
            background: #87CEEB;
            position: relative;
            overflow: hidden;
        }
        
        .tool-group {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .tool-group h3 {
            font-size: 1em;
            margin-bottom: 10px;
            color: #ecf0f1;
        }
        
        .tile-palette {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .tile-button {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 2px black;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tile-button:hover {
            transform: scale(1.1);
            border-color: #3498db;
        }
        
        .tile-button.active {
            border-color: #27ae60;
            border-width: 3px;
            box-shadow: 0 0 10px #27ae60;
        }
        
        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .control-row label {
            flex: 1;
            font-size: 13px;
        }
        
        .control-row input, .control-row select {
            flex: 2;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #555;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        
        .button-group button {
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-success {
            background: #27ae60;
            color: white;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
        }
        
        .hint {
            background: rgba(52, 152, 219, 0.2);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            margin-top: 10px;
            line-height: 1.5;
        }
        
        #chunk-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 5px;
        }
        
        .chunk-item {
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }
        
        .chunk-item:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .chunk-item.active {
            background: #3498db;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h2>ğŸ› ï¸ åœ°å›¾ç¼–è¾‘å™¨</h2>
        
        <div class="tool-group">
            <h3>ğŸ“¦ Chunkç®¡ç†</h3>
            <div class="control-row">
                <label>å½“å‰Stage:</label>
                <select id="stage-select">
                    <option value="0">Stage 0</option>
                    <option value="1">Stage 1</option>
                    <option value="2">Stage 2</option>
                    <option value="3">Stage 3</option>
                    <option value="4">Stage 4</option>
                </select>
            </div>
            <div class="control-row">
                <label>å½“å‰Chunk:</label>
                <select id="chunk-select"></select>
            </div>
            <div class="button-group">
                <button class="btn-primary" id="new-chunk">â• æ–°å»º</button>
                <button class="btn-danger" id="delete-chunk">ğŸ—‘ï¸ åˆ é™¤</button>
                <button class="btn-success" id="copy-chunk">ğŸ“‹ å¤åˆ¶</button>
                <button class="btn-secondary" id="clear-chunk">ğŸ§¹ æ¸…ç©º</button>
            </div>
        </div>
        
        <div class="tool-group">
            <h3>ğŸ¨ ç¼–è¾‘å·¥å…·</h3>
            <div class="control-row">
                <label>å·¥å…·:</label>
                <select id="tool-select">
                    <option value="paint">ğŸ–Œï¸ ç»˜åˆ¶</option>
                    <option value="erase">ğŸ§¹ æ“¦é™¤</option>
                    <option value="fill">ğŸª£ å¡«å……</option>
                    <option value="eyedropper">ğŸ’§ å¸ç®¡</option>
                    <option value="enemy">ğŸ‘¾ æ•Œäºº</option>
                    <option value="obstacle">ğŸš§ éšœç¢</option>
                    <option value="collectible">ğŸ’° æ”¶é›†å“</option>
                </select>
            </div>
            <h3 style="margin-top: 15px;">åœ°å½¢ç±»å‹</h3>
            <div class="tile-palette" id="tile-palette"></div>
        </div>
        
        <div class="tool-group">
            <h3>ğŸ’¾ æ–‡ä»¶æ“ä½œ</h3>
            <div class="button-group">
                <button class="btn-success" id="save-json">ğŸ’¾ ä¿å­˜JSON</button>
                <button class="btn-primary" id="load-json">ğŸ“‚ åŠ è½½</button>
                <button class="btn-secondary" id="export-image">ğŸ–¼ï¸ å¯¼å‡ºå›¾ç‰‡</button>
                <button class="btn-primary" onclick="window.location.href='map_viewer.html'">ğŸ‘ï¸ æŸ¥çœ‹å™¨</button>
            </div>
            <div class="hint">
                ğŸ’¡ æç¤º: ä¿å­˜åçš„JSONæ–‡ä»¶å¯åœ¨æŸ¥çœ‹å™¨ä¸­é¢„è§ˆ
            </div>
        </div>
        
        <div class="tool-group">
            <h3>âŒ¨ï¸ å¿«æ·é”®</h3>
            <div style="font-size: 12px; line-height: 1.8;">
                <div>ğŸ–±ï¸ å·¦é”®: ç»˜åˆ¶/æ”¾ç½®</div>
                <div>ğŸ–±ï¸ å³é”®: æ“¦é™¤</div>
                <div>ğŸ–±ï¸ ä¸­é”®æ‹–æ‹½: ç§»åŠ¨è§†å›¾</div>
                <div>ğŸ¡ æ»šè½®: ç¼©æ”¾</div>
                <div>âŒ¨ï¸ Ctrl+Z: æ’¤é”€</div>
                <div>âŒ¨ï¸ Ctrl+S: ä¿å­˜</div>
                <div>âŒ¨ï¸ ç©ºæ ¼: åˆ‡æ¢ç½‘æ ¼</div>
            </div>
        </div>
    </div>
    
    <div class="main-content">
        <div class="toolbar">
            <button id="zoom-in">ğŸ”+</button>
            <button id="zoom-out">ğŸ”-</button>
            <button id="zoom-reset">â†» é‡ç½®è§†å›¾</button>
            <button id="undo">â†¶ æ’¤é”€</button>
            <button id="redo">â†· é‡åš</button>
            <span style="color: white; margin-left: auto; font-size: 13px;" id="coords"></span>
        </div>
        
        <div id="game-container">
            <div class="status" id="status">å‡†å¤‡å°±ç»ª</div>
        </div>
    </div>

    <script type="module">
        // Tileé¢œè‰²æ˜ å°„
        const TILE_COLORS = {
            0: { color: 0x00000000, name: 'ç©ºæ°”', alpha: 0 },
            1: { color: 0x8B4513, name: 'åœ°é¢', alpha: 1 },
            2: { color: 0xA0522D, name: 'åœ°é¢2', alpha: 1 },
            7: { color: 0x696969, name: 'å¹³å°', alpha: 1 },
            12: { color: 0xA9A9A9, name: 'åŠ¨æ€å¹³å°', alpha: 1 },
            21: { color: 0xFF0000, name: 'å°–åˆº', alpha: 1 },
            23: { color: 0xFFA500, name: 'ç«™ç«‹å¹³å°', alpha: 1 },
            28: { color: 0x00FF00, name: 'åœ°é¢é¡¶', alpha: 1 },
            35: { color: 0xC80000, name: 'é™·é˜±', alpha: 1 },
            48: { color: 0xB40000, name: 'å°–åˆºé™·é˜±', alpha: 1 },
            62: { color: 0x40E0D0, name: 'æ°´', alpha: 1 },
            68: { color: 0xFFD700, name: 'é‡‘å¸', alpha: 1 },
            82: { color: 0x646464, name: 'éšœç¢', alpha: 1 },
            89: { color: 0x964B00, name: 'ç®±å­', alpha: 1 },
        };

        class EditorScene extends Phaser.Scene {
            constructor() {
                super({ key: 'EditorScene' });
                this.tileSize = 16; // ç¼–è¾‘å™¨ä½¿ç”¨æ›´å¤§çš„tileæ–¹ä¾¿ç¼–è¾‘
                this.gridSize = 100; // chunkå®½åº¦
                this.gridHeight = 30; // chunké«˜åº¦
                this.currentTile = 1;
                this.currentTool = 'paint';
                this.showGrid = true;
                this.zoomLevel = 1.5;
                this.stageData = null;
                this.currentStage = 0;
                this.currentChunk = 0;
                this.terrain = [];
                this.entities = { enemies: [], obstacles: [], collectibles: [] };
                this.history = [];
                this.historyIndex = -1;                this.isDragging = false;
                this.spaceKeyDown = false;                this.isDragging = false;
            }

            preload() {
                // åŠ è½½æ‰€æœ‰stageæ•°æ®
                for (let i = 0; i < 5; i++) {
                    this.load.json(`stage${i}`, `../map_data/stage${i}.json`);
                }
                
                // é¢„åŠ è½½plano1 sprites (åœ°å½¢)
                // plano1æœ‰55ä¸ªspriteï¼Œtileå€¼0-54æ˜¯åŸå§‹ï¼Œ55-108æ˜¯æ°´å¹³ç¿»è½¬ï¼Œ109-162æ˜¯å‚ç›´ç¿»è½¬
                for (let i = 0; i < 55; i++) {
                    this.load.image(`tile_${i}`, `sprites/plano1/sprite_${i.toString().padStart(3, '0')}.png`);
                }
            }

            create() {
                this.cameras.main.setBackgroundColor('#87CEEB');
                this.cameras.main.setZoom(this.zoomLevel);
                
                // åˆå§‹åŒ–ç©ºterrain
                this.initEmptyTerrain();
                
                // åŠ è½½stage 0 chunk 0
                this.loadChunk(0, 0);
                
                // æ¸²æŸ“åœ°å›¾
                this.renderMap();
                
                // è®¾ç½®è¾“å…¥
                this.setupInput();
                
                // æ›´æ–°çŠ¶æ€
                this.updateStatus('ç¼–è¾‘å™¨å·²å°±ç»ª');
            }

            initEmptyTerrain() {
                this.terrain = [];
                for (let y = 0; y < this.gridHeight; y++) {
                    const row = [];
                    for (let x = 0; x < this.gridSize; x++) {
                        row.push(0);
                    }
                    this.terrain.push(row);
                }
            }

            loadChunk(stageIndex, chunkIndex) {
                this.currentStage = stageIndex;
                this.currentChunk = chunkIndex;
                
                const stageData = this.cache.json.get(`stage${stageIndex}`);
                if (!stageData || !stageData.chunks[chunkIndex]) {
                    this.initEmptyTerrain();
                    this.entities = { enemies: [], obstacles: [], collectibles: [] };
                    return;
                }
                
                const chunk = stageData.chunks[chunkIndex];
                this.terrain = JSON.parse(JSON.stringify(chunk.terrain));
                this.entities = {
                    enemies: JSON.parse(JSON.stringify(chunk.enemies || [])),
                    obstacles: JSON.parse(JSON.stringify(chunk.obstacles || [])),
                    collectibles: JSON.parse(JSON.stringify(chunk.collectibles || []))
                };
                
                this.renderMap();
                this.saveHistory();
                this.updateStatus(`åŠ è½½ Stage ${stageIndex} Chunk ${chunkIndex}`);
            }

            renderMap() {
                // æ¸…é™¤æ‰€æœ‰å¯¹è±¡
                this.children.removeAll();
                
                // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
                if (this.showGrid) {
                    this.drawGrid();
                }
                
                // ç»˜åˆ¶åœ°å½¢
                // plano1æœ‰55ä¸ªspriteï¼Œtileå€¼æ˜ å°„:
                // 0-54: åŸå§‹sprite
                // 55-108: æ°´å¹³ç¿»è½¬ (sprite = tile - 55)
                // 109-162: å‚ç›´ç¿»è½¬ (sprite = tile - 109)
                const NUM_SPRITES = 55;
                
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const tileValue = this.terrain[y][x];
                        if (tileValue === 0) continue;
                        
                        const px = x * this.tileSize;
                        const py = y * this.tileSize;
                        
                        // è®¡ç®—spriteç´¢å¼•å’Œç¿»è½¬
                        let spriteIndex = tileValue;
                        let flipX = false;
                        let flipY = false;
                        
                        if (tileValue >= NUM_SPRITES * 2) {
                            // å‚ç›´ç¿»è½¬
                            spriteIndex = tileValue - NUM_SPRITES * 2;
                            flipY = true;
                        } else if (tileValue >= NUM_SPRITES) {
                            // æ°´å¹³ç¿»è½¬
                            spriteIndex = tileValue - NUM_SPRITES;
                            flipX = true;
                        }
                        
                        // å°è¯•ä½¿ç”¨spriteå›¾ç‰‡
                        const textureKey = `tile_${spriteIndex}`;
                        if (this.textures.exists(textureKey)) {
                            const sprite = this.add.image(px, py, textureKey);
                            sprite.setOrigin(0, 0);
                            sprite.setFlipX(flipX);
                            sprite.setFlipY(flipY);
                            // ç¼©æ”¾åˆ°tileSize (ç¼–è¾‘å™¨ç”¨16px)
                            sprite.setDisplaySize(this.tileSize, this.tileSize);
                        } else {
                            // å›é€€åˆ°é¢œè‰²æ–¹å—
                            const tileInfo = TILE_COLORS[tileValue] || { color: 0x505050, alpha: 1 };
                            const rect = this.add.rectangle(
                                px, py,
                                this.tileSize,
                                this.tileSize,
                                tileInfo.color,
                                tileInfo.alpha
                            );
                            rect.setOrigin(0, 0);
                            rect.setStrokeStyle(1, 0x000000, 0.3);
                        }
                    }
                }
                
                // ç»˜åˆ¶å®ä½“
                this.entities.enemies.forEach(e => {
                    const circle = this.add.circle(
                        e.x * this.tileSize + this.tileSize / 2,
                        e.y * this.tileSize + this.tileSize / 2,
                        this.tileSize / 2,
                        0xFF0000
                    );
                    const text = this.add.text(
                        e.x * this.tileSize + this.tileSize / 2,
                        e.y * this.tileSize + this.tileSize / 2,
                        'E',
                        { fontSize: '12px', color: '#FFF' }
                    );
                    text.setOrigin(0.5);
                });
                
                this.entities.obstacles.forEach(o => {
                    this.add.rectangle(
                        o.x * this.tileSize,
                        o.y * this.tileSize,
                        this.tileSize,
                        this.tileSize,
                        0x800080,
                        0.8
                    ).setOrigin(0, 0);
                });
                
                this.entities.collectibles.forEach(c => {
                    this.add.circle(
                        c.x * this.tileSize + this.tileSize / 2,
                        c.y * this.tileSize + this.tileSize / 2,
                        this.tileSize / 3,
                        0xFFD700
                    );
                });
            }

            drawGrid() {
                const graphics = this.add.graphics();
                graphics.lineStyle(1, 0x000000, 0.1);
                
                for (let x = 0; x <= this.gridSize; x++) {
                    graphics.lineBetween(
                        x * this.tileSize, 0,
                        x * this.tileSize, this.gridHeight * this.tileSize
                    );
                }
                
                for (let y = 0; y <= this.gridHeight; y++) {
                    graphics.lineBetween(
                        0, y * this.tileSize,
                        this.gridSize * this.tileSize, y * this.tileSize
                    );
                }
            }

            setupInput() {
                // é¼ æ ‡ç‚¹å‡»
                this.input.on('pointerdown', (pointer) => {
                    if (this.spaceKeyDown && pointer.button === 0) { // ç©ºæ ¼+å·¦é”®æ‹–æ‹½
                        this.isDragging = true;
                        return;
                    }
                    
                    const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
                    const tileX = Math.floor(worldPoint.x / this.tileSize);
                    const tileY = Math.floor(worldPoint.y / this.tileSize);
                    
                    if (tileX < 0 || tileX >= this.gridSize || tileY < 0 || tileY >= this.gridHeight) {
                        return;
                    }
                    
                    if (pointer.button === 0) { // å·¦é”®
                        this.handlePaint(tileX, tileY);
                    } else if (pointer.button === 2) { // å³é”®
                        this.handleErase(tileX, tileY);
                    }
                    
                    this.renderMap();
                    this.saveHistory();
                });
                
                // é¼ æ ‡ç§»åŠ¨
                this.input.on('pointermove', (pointer) => {
                    const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
                    const tileX = Math.floor(worldPoint.x / this.tileSize);
                    const tileY = Math.floor(worldPoint.y / this.tileSize);
                    
                    document.getElementById('coords').textContent = 
                        `X: ${tileX} Y: ${tileY} | Tile: ${this.terrain[tileY]?.[tileX] || 0}`;
                    
                    if (this.isDragging && pointer.isDown) {
                        this.cameras.main.scrollX -= pointer.velocity.x / this.zoomLevel;
                        this.cameras.main.scrollY -= pointer.velocity.y / this.zoomLevel;
                    } else if (pointer.isDown && pointer.button === 0 && !this.spaceKeyDown) {
                        if (tileX >= 0 && tileX < this.gridSize && tileY >= 0 && tileY < this.gridHeight) {
                            this.handlePaint(tileX, tileY);
                            this.renderMap();
                        }
                    }
                });
                
                this.input.on('pointerup', () => {
                    this.isDragging = false;
                    this.saveHistory();
                });
                
                // ç¦ç”¨å³é”®èœå•
                this.input.mouse.disableContextMenu();
                
                // é”®ç›˜æ§åˆ¶
                this.input.keyboard.on('keydown-SPACE', () => {
                    this.spaceKeyDown = true;
                });
                
                this.input.keyboard.on('keyup-SPACE', () => {
                    this.spaceKeyDown = false;
                    this.isDragging = false;
                });
                
                // æ»šè½®ç¼©æ”¾
                this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY) => {
                    if (deltaY > 0) {
                        this.zoomLevel = Math.max(0.5, this.zoomLevel - 0.1);
                    } else {
                        this.zoomLevel = Math.min(4, this.zoomLevel + 0.1);
                    }
                    this.cameras.main.setZoom(this.zoomLevel);
                });
            }

            handlePaint(x, y) {
                if (this.currentTool === 'paint') {
                    this.terrain[y][x] = this.currentTile;
                } else if (this.currentTool === 'erase') {
                    this.terrain[y][x] = 0;
                    this.removeEntity(x, y);
                } else if (this.currentTool === 'fill') {
                    this.floodFill(x, y, this.terrain[y][x], this.currentTile);
                } else if (this.currentTool === 'eyedropper') {
                    this.currentTile = this.terrain[y][x];
                    document.querySelectorAll('.tile-button').forEach(btn => {
                        btn.classList.toggle('active', parseInt(btn.dataset.tile) === this.currentTile);
                    });
                } else if (this.currentTool === 'enemy') {
                    this.addEntity('enemies', x, y);
                } else if (this.currentTool === 'obstacle') {
                    this.addEntity('obstacles', x, y);
                } else if (this.currentTool === 'collectible') {
                    this.addEntity('collectibles', x, y);
                }
            }

            handleErase(x, y) {
                this.terrain[y][x] = 0;
                this.removeEntity(x, y);
            }

            addEntity(type, x, y) {
                // ç§»é™¤è¯¥ä½ç½®å·²æœ‰çš„åŒç±»å®ä½“
                this.entities[type] = this.entities[type].filter(e => !(e.x === x && e.y === y));
                this.entities[type].push({ type: 0, x, y });
            }

            removeEntity(x, y) {
                ['enemies', 'obstacles', 'collectibles'].forEach(type => {
                    this.entities[type] = this.entities[type].filter(e => !(e.x === x && e.y === y));
                });
            }

            floodFill(x, y, targetColor, replacementColor) {
                if (targetColor === replacementColor) return;
                if (x < 0 || x >= this.gridSize || y < 0 || y >= this.gridHeight) return;
                if (this.terrain[y][x] !== targetColor) return;
                
                this.terrain[y][x] = replacementColor;
                
                this.floodFill(x + 1, y, targetColor, replacementColor);
                this.floodFill(x - 1, y, targetColor, replacementColor);
                this.floodFill(x, y + 1, targetColor, replacementColor);
                this.floodFill(x, y - 1, targetColor, replacementColor);
            }

            saveHistory() {
                const state = {
                    terrain: JSON.parse(JSON.stringify(this.terrain)),
                    entities: JSON.parse(JSON.stringify(this.entities))
                };
                
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(state);
                this.historyIndex++;
                
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    const state = this.history[this.historyIndex];
                    this.terrain = JSON.parse(JSON.stringify(state.terrain));
                    this.entities = JSON.parse(JSON.stringify(state.entities));
                    this.renderMap();
                    this.updateStatus('æ’¤é”€');
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    const state = this.history[this.historyIndex];
                    this.terrain = JSON.parse(JSON.stringify(state.terrain));
                    this.entities = JSON.parse(JSON.stringify(state.entities));
                    this.renderMap();
                    this.updateStatus('é‡åš');
                }
            }

            exportJSON() {
                const chunk = {
                    id: this.currentChunk,
                    terrain: this.terrain,
                    enemies: this.entities.enemies,
                    obstacles: this.entities.obstacles,
                    collectibles: this.entities.collectibles
                };
                
                const json = JSON.stringify(chunk, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `stage${this.currentStage}_chunk${this.currentChunk}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.updateStatus(`å¯¼å‡º chunk${this.currentChunk}.json`);
            }

            updateStatus(message) {
                document.getElementById('status').textContent = message;
            }
        }

        // Phaseré…ç½®
        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth - 300,
            height: window.innerHeight - 60,
            parent: 'game-container',
            backgroundColor: '#87CEEB',
            scene: EditorScene,
            pixelArt: true
        };

        const game = new Phaser.Game(config);
        
        // ç­‰å¾…åœºæ™¯åˆ›å»ºå®Œæˆåå†è®¾ç½®æ‰€æœ‰UIæ§åˆ¶
        game.events.once('ready', () => {
            const scene = game.scene.scenes[0];

            // åˆå§‹åŒ–tileè°ƒè‰²æ¿
            function initTilePalette() {
                const palette = document.getElementById('tile-palette');
                Object.entries(TILE_COLORS).forEach(([value, info]) => {
                    const btn = document.createElement('div');
                    btn.className = 'tile-button';
                    if (parseInt(value) === scene.currentTile) {
                        btn.classList.add('active');
                    }
                    btn.dataset.tile = value;
                    btn.style.backgroundColor = '#' + info.color.toString(16).padStart(6, '0');
                    btn.textContent = info.name;
                    btn.onclick = () => {
                        scene.currentTile = parseInt(value);
                        document.querySelectorAll('.tile-button').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    };
                    palette.appendChild(btn);
                });
            }

            // åˆå§‹åŒ–chunké€‰æ‹©å™¨
            function updateChunkSelect() {
                const select = document.getElementById('chunk-select');
                select.innerHTML = '';
                for (let i = 0; i < 6; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `Chunk ${i}`;
                    select.appendChild(option);
                }
                select.value = scene.currentChunk;
            }

            // UIäº‹ä»¶
            document.getElementById('stage-select').addEventListener('change', (e) => {
                scene.loadChunk(parseInt(e.target.value), scene.currentChunk);
            });

            document.getElementById('chunk-select').addEventListener('change', (e) => {
                scene.loadChunk(scene.currentStage, parseInt(e.target.value));
            });

            document.getElementById('tool-select').addEventListener('change', (e) => {
                scene.currentTool = e.target.value;
            });

            document.getElementById('new-chunk').addEventListener('click', () => {
                scene.initEmptyTerrain();
                scene.entities = { enemies: [], obstacles: [], collectibles: [] };
                scene.renderMap();
                scene.saveHistory();
                scene.updateStatus('åˆ›å»ºæ–°chunk');
            });

            document.getElementById('clear-chunk').addEventListener('click', () => {
                if (confirm('ç¡®å®šè¦æ¸…ç©ºå½“å‰chunkå—ï¼Ÿ')) {
                    scene.initEmptyTerrain();
                    scene.entities = { enemies: [], obstacles: [], collectibles: [] };
                    scene.renderMap();
                    scene.saveHistory();
                    scene.updateStatus('æ¸…ç©ºchunk');
                }
            });

            document.getElementById('save-json').addEventListener('click', () => {
                scene.exportJSON();
            });

            document.getElementById('zoom-in').addEventListener('click', () => {
                scene.zoomLevel = Math.min(4, scene.zoomLevel + 0.25);
                scene.cameras.main.setZoom(scene.zoomLevel);
            });

            document.getElementById('zoom-out').addEventListener('click', () => {
                scene.zoomLevel = Math.max(0.5, scene.zoomLevel - 0.25);
                scene.cameras.main.setZoom(scene.zoomLevel);
            });

            document.getElementById('zoom-reset').addEventListener('click', () => {
                scene.zoomLevel = 1.5;
                scene.cameras.main.setZoom(scene.zoomLevel);
                scene.cameras.main.scrollX = 0;
                scene.cameras.main.scrollY = 0;
            });

            document.getElementById('undo').addEventListener('click', () => scene.undo());
            document.getElementById('redo').addEventListener('click', () => scene.redo());

            // é”®ç›˜å¿«æ·é”®
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    scene.undo();
                } else if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    scene.redo();
                } else if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    scene.exportJSON();
                }
            });

            // åˆå§‹åŒ–
            initTilePalette();
            updateChunkSelect();
        });
    </script>
</body>
</html>
